# Материал на тему «Асинхронность»

## Общие понятия
В языке C# можно вызывать команды как синхронно, так и асинхронно. При синхронном вызове команды будут выполняться последовательно, "синхронизированно".
Когда при асинхронном вызове это необязательно: действия могут выполняться в фоновом режиме, параллельно вызвавшему их процессу. Такой подход полезен при
использовании ресурсов вне системы, исполняющей код, например: HTTP-запрос к другому серверу, запрос данных к базе данных, расположенной в облаке, или к внешнему устройству.
Также, такой подход позволяет параллельно выполнять несколько задач, без блокировки основного потока.

Для асинхронности в C# характерны ключевые слова ```async``` и ```await```, а также тип ```Task``` или ```Task<T>```:
- ```async``` обозначает использование асинхронного вызова объявленного метода.
- ```await``` указывает на начало выполнения асинхронного метода. При использовании данного ключевого слова система понимает, что следующее действие будет выполняться 
в асинхронном режиме, и после его окончания нужно будет продолжить работу с того места, на котором выполнение остановилось. При этом, наши ресурсы, в виде исполняющего потока, 
не будут простаивать и ожидать окончания асинхронного действия, а могут быть переиспользованы для выполнения задач в других частях приложения.
- ```Task``` - представляет собой задачу, которая выполняется асинхронно. Если задача ничего не возвращает, то она имеет тип - ```Task```, в ином случае - тип ```Task<T>```, 
где T - тип возвращаемого объекта, например: ```Task<int>``` или ```Task<string>```.


## Пример №1
Функция ```AsyncExample1``` демонстрирует использование асинхронных функций. Данная функция имеет в своем описании ключевое слово ```async``` и тип ```Task<IActionResult>```,
по данным параметрам мы можем определить, что функция работает с асинхронным кодом.

Внутри данной функции двумя разными способами вызывается другая асинхронная функция ```CalcCircumferenceAsync```, которая считает длину окружности и ожидает 1 секунду.
Для того, чтобы получить значение длины окружности, нам нужно дождаться окончания работы асинхронного метода, и мы делаем это 2 разными способами:
- Используя ключевое слово ```await```
- Используя поле ```Result```

При использовании поля ```Result``` основной поток останавливается при вызове асинхронного метода и ожидает его окончания. Пользоваться этим полем следует только если 
мы работаем в синхронной части кода, когда у нас нет возможности вызвать await. Поскольку метод ```AsyncExample1``` помечен ключевым словом ```async```, мы можем использовать
в нем ```await``` для ожидания результата, и это будет верным вариантом использования асинхронности.


## Пример №2
Функция ```AsyncExample2``` демонстрирует использование асинхронных функций аналогично предыдущей, но в данном примере вызывается функция ```DoAsyncWork```, которая не 
возвращает результата. Для ожидания данной функции мы так же можем воспользоваться разными методами:

- Используя ключевое слово ```await```
- Используя метод ```Wait()```

Логика работы двух этих методов будет аналогична логике в первом примере - Wait() заставляет вызывающий поток ожидать окончания результата, когда await освобождает его 
для выполнения других задач.


## Пример №3
Функция ```AsyncExample2``` демонстрирует использование асинхронных функций для параллельных вычислений. В примере выполняются 3 асинхронные задачи, которые исполняются 
1, 2 и 3 секунды каждая сначала поочередно, а затем параллельно.

Запуск задач поочередно с ожиданием ничем не отличается от запуска асинхронных задач в предыдущих примерах. А для параллельного запуска задач мы пользуемся методом класса 
```Task``` - ```WaitAll```, который создает задачу, ожидающую выполнение всех переданных ему асинхронных функций. Таким образом мы используем асинхронные задачи для 
параллельного выполнения нескольких действий, контролируя их исполнение.

Также важно отметить, что когда мы используем асинхронный метод ```DoSomeWork``` без использования ключевого слова ```await```, мы запускаем задачу асинхронную задачу и 
переходим к исполнению следующей команды в основном методе. Так, например, если бы наш код был вида:

```csharp
public async Task AsyncExample3Plus()
{
    var task1 = DoAsyncWork(1000);
    var task2 = DoAsyncWork(2000);
    var task3 = DoAsyncWork(3000);
    await task1;
    await task2;
    await task3;
}
```
То время выполнения данного метода равнялось бы времени исполнению наиболее долгой из задач, т.е. 3 секундам. Такое происходит, потому что мы запустили все задачи 
практически одновременно, когда вызвали метод DoAsyncWork и записали ссылки на задачи в переменные ```task1```, ```task2``` и ```task3```.
